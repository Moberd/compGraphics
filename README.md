<h1>Лабораторная работа №1 Работа в графическом режиме</h1>
<h3>Построение графика функции</h3>
Задаются: диапазон значений, функция, необходимо построить график с возможностью масштабирования – в максимальных и минимальных точках график касается верхних и нижних границ графического окна. Обязательный тест – sin(x) и x^2.
Необходимо предусмотреть выбор функций из некоторого списка. В функцию построения графика функцию передавать как параметр.
Не использовать стандартные функции построения графиков.
Язык программирования - любой.


<h1>Лабораторная работа №2. Цветовые пространства. Преобразование цветовых пространств.</h1>
<ol>
<li>Преобразовать изображение из RGB в оттенки серого. Реализовать два варианта формулы с учетом разных вкладов R, G и B в интенсивность (см презентацию). Затем найти разность полученных полутоновых изображений. Построить гистограммы интенсивности после одного и второго преобразования.</li>
<li>Выделить из полноцветного изображения каждый из каналов R, G, B  и вывести результат. Построить гистограмму по цветам (3 штуки).</li>
<li>Преобразовать изображение из RGB в HSV. Добавить возможность изменять значения оттенка, насыщенности и яркости. Результат сохранять в файл, предварительно преобразовав обратно.</li>
</ol>


<h1>Лабораторная работа №3. Растровые алгоритмы</h1>
<ol>
<li>
<ol>
<li>Рекурсивный алгоритм заливки на основе серий пикселов (линий)  заданным цветом.</li>
<li>Рекурсивный алгоритм заливки на основе серий пикселов (линий)  рисунком из графического файла. Файл можно загрузить встроенными средствами и затем считывать точки изображения для использования в заливке. Рассмотреть случаи когда файл небольшого размера и заливается циклически и когда большой. Масштабировать не нужно.  Область рисуется мышкой. Область произвольной формы. Внутри могут быть отверстия. Точка, с которой начинается заливка, задается щелчком мыши.</li>
<li>Выделение границы связной области. На вход подается изображение. Граница связной области задается одним цветом. Имея начальную точку границы организовать ее обход, занося точки в список в порядке обхода. Начальную точку границы можно получать любым способом. Для контроля полученную границу прорисовать поверх исходного изображения.</li>
</ol>
</li>
<li>Реализовать рисование отрезка: целочисленным алгоритмом Брезенхема  и алгоритмом ВУ</li>
<li>Выполнить градиентное окрашивание произвольного треугольника, у которого все три вершины разного цвета, используя алгоритм растеризации треугольника.</li>
</ol>


<h1>Лабораторная работа №4. Аффинные преобразования на плоскости и вспомогательные алгоритмы</h1>
<h3>Программа должна содержать следующие возможности:</h3>
<ol>
<li>Задать текущий примитив: точка, ребро (отрезок), полигон (мин требование -- квадрат). Они рисуются мышкой.</li>
<li>Очистить сцену.</li>
<li>Применение аффинных преобразований к полигону: смещение на dx, dy; поворот вокруг произвольной точки (точка задается пользователем мышкой) и/или вокруг своего центра; масштабирование относительно произвольной точки (точка задается пользователем мышкой) и/или относительно своего центра. Все преобразования должны быть реализованы матрицами!</li>
<li>Поворот ребра на 90 градусов вокруг своего центра.</li>
<li>Поиск точки пересечения двух ребер (добавление второго ребра мышкой, динамически).</li>
</ol>
<h3>Программа должна позволять выполнить следующие проверки:</h3>
<ol>
<li>Принадлежит ли точка выпуклому многоугольнику (задание точки мышкой).</li>
<li>Принадлежит ли точка невыпуклому многоугольнику (задание точки мышкой).</li>
<li>Классифицировать положение точки относительно ребра (задание точки мышкой).</li>
</ol>

<h1>Лабораторная работа №5. L-системы. Алгоритм midpoint displacement. Кривые Безье</h1>
1. L-системы
1.a 

Реализовать программу для построения фрактальных узоров посредством L-систем.

Описание L-систем задается в текстовом файле вида:

<атом> <угол поворота> <начальное направление> 
<правило №1>
<правило №2>
...

Реализовать возможность разветвления в системе (скобки) и возможность добавления случайности.
Предусмотреть масштабирование получаемого набора точек (должен помещаться в окне).
В качестве тестов использовать фракталы из лекций.


1.б 

Создать фрактальное дерево с изменением толщины от основания к ветвям, изменением цвета от коричневого к зеленому и случайным изменениям угла у ветвей

2. Алгоритм midpoint displacement
Реализовать алгоритм midpoint displacement для двумерной визуализации горного массива.
Необходимо отображать результаты последовательных шагов алгоритма. Программа должна позволять изменять параметры построения ломаной.

3. Кубические сплайны Безье
Реализовать программу для визуализации составной кубической кривой Безье. 
Программа должна позволять добавлять, удалять  и перемещать опорные точки. 


<h1>Лабораторная работа №6. Аффинные преобразования в пространстве. Проецирование</h1>
Просьба ознакомиться с содержанием лабораторных работ №№7-9. Их реализация базируется на классах из этой лабораторной, планируйте соответственно.

В программе должны присутствовать следующие классы: точка, прямая (ребро), многоугольник (грань), многогранник.

Программа должна содержать следующие возможности:

Отображение одного из правильных многогранников: тетраэдр, гексаэдр, октаэдр, икосаэдр*, додекаэдр*.
Применение аффинных преобразований: смещение, поворот, масштаб, с указанием параметров преобразования. Преобразования должны быть реализованы матрицами!

Отражение относительно выбранной координатной плоскости.
Масштабирование многогранника относительно своего центра.
Вращение многогранника вокруг прямой проходящей через центр многогранника, параллельно выбранной координатной оси.
Поворот вокруг произвольной (заданной координатами двух точек) прямой на заданный угол.
Предусмотреть возможность переключения между проекциями :

перспективной;
аксонометрической
Все преобразования должны быть реализованы матрицами

 * – необязательная реализация за бонусные баллы


<h1>Лабораторная работа №7. Построение трёхмерных моделей</h1>
На основе Лабораторной работы №6:

1. Загрузка и сохранение модели многогранника из файла
Формат модели должен содержать данные о гранях. Формат файла выбирается программистом.

Необходимо отобразить загруженную модель, позволить применять к ней аффинные преобразования. 

Для тестов можно использовать модели многогранников из Лаб. №6.

2. Построение фигуры вращения
Фигура вращения задаётся тремя параметрами: образующей (набор точек), осью вращения и количеством разбиений. Угол вращений можно вычислить, поделив 360° на количество разбиений.

Программа должна давать возможность задать образующую и построить фигуру вращения относительно выбранной координатной оси с заданным количеством разбиений. Формат модели должен содержать данные о гранях.

Сохранить полученную модель в файл.*

Необходимо загрузить* и отобразить полученную модель, применить к ней аффинные преобразования.

 * – необязательная реализация за бонусные баллы 

3. Построение графика двух переменных
Сегмент поверхности задаётся функцией f(x, y) = z, диапазонами отсечения [x0, x1], [y0, y1] и количеством разбиений по осям (шагом).

Программа должна позволять строить сегмент поверхности, заданный выбранной функцией на заданном диапазоне с заданным количеством разбиений. Формат модели должен содержать данные о гранях. Диапазоны и разбиения можно задавать идентичными для X и Y.

Необходимо отобразить полученную модель, позволить применять к ней аффинные преобразования.

Загрузить и Сохранить полученную модель в файл.* 

 * – необязательная реализация за бонусные баллы 


<h1>Лабораторная работа №8. Удаление невидимых граней</h1>

1. Отсечение нелицевых граней
Изобразить вращающийся объект (созданный ранее) с отсечением нелицевых граней:

Добавить к каждой грани вектор нормали, направленный вовне, относительно объекта. Вектор нормали вычисляется, как векторное произведение векторов, лежащих в плоскости грани.
Задать вектор обзора (Можно только параллельную проекцию использовать, а можно переключаться между параллельной и перспективной). Добавить возможность его изменения.
Реализовать отсечение нелицевых граней с учетом вектора нормали и направления обзора.

2. Алгоритм Z-буфера

Реализовать алгоритм z-буфера для удаления невидимых граней. Направление обзора может быть фиксированным (Можно только параллельную проекцию использовать, а можно переключаться между параллельной и перспективной).

Добавить возможность применять преобразования к отображаемому объекту.
Если объект выпуклый, то необходимо добавить еще несколько объектов для демонстрации корректной работы алгоритма в случае перекрытия.

3. Камера
Добавить объект-камеру. 

Камера задается своим положением, направлением обзора и матрицей проекционного преобразования. 
Получить изображение с камеры, вращая её вокруг статического объекта (Перспективная проекция). 


<h1>Лабораторная работа № 9. Освещение и текстурирование</h1>

1. Освещение

Реализовать метод Гуро для затенения фигур. (например, для кубика, удаляя нелицевые грани)
Добавить нормаль к каждой вершине.
Добавить положение источника света и цвет объекта.
Вычислить цвет в каждой вершине по модели Ламберта (рассеянную часть).
Закрасить грань, интерполируя цвет между цветами вершин (билинейная интерполяция).
Добавить возможность применения аффинных преобразований к объекту.

2. Текстурирование

Реализовать алгоритм наложения текстуры на полигон. (например, для кубика, удаляя нелицевые грани)
Добавить координаты текстуры к каждой вершине.
При отрисовке грани интерполировать координаты текстуры между координатами вершин.
Продемонстрировать текстурирование на правильных многогранниках (тетраэдр, куб, октаэдр).
Добавить возможность применения преобразований к объекту.

3. Метод плавающего горизонта

Построить проекцию графика функции 2-х переменных: по алгоритму плавающего горизонта.
Реализовать отображение линиями или сеткой или треугольниками.
Добавить возможность менять направление обзора.


<h1>Лабораторная работа № 10. Зелёный треугольник</h1>
Зелёный треугольник
Прежде чем начать
Если вы используете WebGl, то все необходимые примитивы для работы с канвасами и пользовательским вводом достаются вам бесплатно из html и js.

В противном случае (если вы пишете на C++, Rust, и т.п.), вам необходимо установить библиотеку для работы с окнами и пользовательским вводом. Мы рекомендуем использовать SFML. Код инициализации окна можно взять, например, из презентации.

Порядок действий
Инициализировать шейдеры (вершинный и фрагментный)

Объекты шейдеров создаются функцией glCreateShader.
Инициализируются исходным кодом функцией glShaderSource
Компилируется функцией glCompileShader
Обработать ошибки (см. пункт про обработку ошибок далее)
Инициализировать шейдерную программу

Создаём шейдерную программу: glCreateProgram
Присоединяем каждый шейдер функцией glAttachShader
Линкуем программу glLinkProgram
Обработать ошибки
Получить id аттрибутов из шейдерной программы

Используем функцию glGetAttribLocation
Если индекс, возвращённый glGetAttribLocation оказался -1, то вы сделали что-то не так
Инициализировать VBO
VBO — это массив данных в видеопамяти.

Создаём VBO: glGenBuffers
Биндим VBO: glBindBuffer (подробнее об этом далее)
Заполняем его данными функцией glBufferData
Отрисовать сцену

Установить шейдерную программу текущей: glUseProgram
Вызываем демонов функцией glEnableVertexAttribArray
Биндим VBO: glBindBuffer
Привязываем к нему аттрибут: glVertexAttribPointer
Можно рисовать: glDrawArrays
Обработать ошибки
Очистить ресурсы
Когда штуки больше не нужны, их надо удалять

Удаление шейдерной программы: glDeleteProgram
Удаление VBO: glDeleteBuffers
Обработка ошибок
После каждого действия надо спрашивать OpenGL успешно ли он с этим действием справился.

Обработка ошибок компиляции шейдеров
Для получения результатов компиляции каждого шейдера (функция glCompileShader) можно использовать следующую функцию

void ShaderLog(unsigned int shader)
{
    int infologLen = 0;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infologLen);
    if (infologLen > 1)
    {
        int charsWritten = 0;
        std::vector<char> infoLog(infologLen);
        glGetShaderInfoLog(shader, infologLen, &charsWritten, infoLog.data());
        std::cout << "InfoLog: " << infoLog.data() << std::endl;
    }
}
Обработка других ошибок
Результат большинства функций в OpenGL, которые могут закончиться неудачей, можно получить функцией glGetError. Она возвращает код ошибки, трактовку которого и пример использования функции можно получить в документации.

Обработка ошибок в WebGL
В WebGL ошибки следует обрабатывать, как стандартный Exception (но иногда он их просто пишет в консоль)

Биндинг
В процессе работы с различными примитивами OpenGl мы нередко сталкиваемся с функциями вида glBind.... Это работает следующим образом. В памяти OpenGL существует переменная, отвечающая за то, с каким объектом мы работаем в данный момент. Этот объект как раз выбирается функциями glBind....

Например при заполнении VBO мы сначала сообщаем OpenGL, с каким буфером мы сейчас будем работать:

glBindBuffer(GL_ARRAY_BUFFER, VBO);
Затем вызываем функцию, заполняющую его данными:

glBufferData(GL_ARRAY_BUFFER, sizeof(triangle), triangle, GL_STATIC_DRAW);
Хорошим тоном считается после использования разбиндить буфер, вызвав

glBindBuffer(GL_ARRAY_BUFFER, NULL);
  

<h1>Лаб.11. Построение различные 2D фигур. Плоское закрашивание. Uniform</h1>
  
Далее термин "градиентный" обозначает, что каждая вершина должна быть своего цвета. Цвета должны интерполироваться между вершинами.

Задания

Нарисовать четырехугольник, веер, правильный пятиугольник. Для этого меняете количество точек и параметр в glDrawArrays(GL_TRIANGLES, 0, 3); 
  
Закрасить каждую из фигур плоским закрашиванием - цвет задать константой в шейдере.
  
Закрасить каждую из фигур плоским закрашиванием - цвет передать во  фрагментный шейдер через uniform-переменные из основной программы.


<h1>Лаб. 12. Атрибуты, юниформы и трёхмерные объекты в OpenGL. Наложение текстур</h1>
  Задания

Градиентный тетраэдр, который можно двигать вдоль осей кнопками клавиатуры. Он должен быть повёрнут так, чтобы было видно, что это тетраэдр.
  
Кубик с наложенной на него текстурой. Текстура должна быть смешана с цветами, пропорция регулируется кнопками клавиатуры.
  
Кубик с двумя смешанными текстурами. Пропорция должна регулироваться кнопками клавиатуры.
  
Градиентный круг (окружность проходит Hue из HSV, центр белый), который можно масштабировать по осям (каждую ось своей кнопкой).
  
Для передачи координат, цветов вершин и текстурных координат необходимо использовать VBO.

Для управления с клавиатуры необходимо передавать дополнительную информацию в шейдер с помощью uniform.
  
  
<h1>Лаб. 13. Загрузка файлов, множественные объекты</h1>
  Солнечная система
Загрузка моделей из файлов
  
Необходимо реализовать загрузку моделей из файлов (например в формате obj). Должны загржаться как минимум координаты вершин и текстурные координаты. Обратите внимание, что использовать стоит не шарики, пусть планетами будут что-нибудь неожиданное, порадуйте преподавателя своим воображением! (не меньше 100 полигонов).

Отрисовка множественных моделей
  
Необходимо отрисовать несколько (не менее пяти) экземпляров загруженного объекта в разных местах. При этом загружать данные в память нужно лишь один раз. На объекты должны быть наложена текстура в соответствии с распаршеными текстурными координатами.

Движение по орбите
  
Сделать так, чтобы объекты выстроились в модель солнечной системы:

В центре самый большой объект
  
Вокруг него по круглым орбитам вращаются объекты поменьше (все разных размеров)
  
Все объекты так же вращаются вокруг своей оси
  
Камера
  
Камера (с перспективной проекцией) должна уметь двигаться вперёд-назад/вверх-вниз (опционально вправо-влево). Её можно поворачивать вертикально и горизонтально (не забывайте, что для камеры "вперёд" -- это то, куда она смотрит).
  
  
<h1>И тд</h1>
